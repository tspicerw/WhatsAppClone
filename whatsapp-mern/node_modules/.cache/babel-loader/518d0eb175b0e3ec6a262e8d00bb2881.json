{"ast":null,"code":"var errors = require('./errors');\n\nvar util = require('./util');\n\nvar Token = require('./token');\n/** Provides validation and access methods for a WebHook.\n *\n * Before accessing WebHook data, check if it's valid. Otherwise, exceptions\n * will be raised from access methods.\n *\n * @constructor\n * @param {Token} primary token\n * @param {Object} request\n * @param {Object} request.headers WebHook HTTP headers with lower-case keys\n * @param {String} request.rawBody raw WebHook body\n */\n\n\nfunction WebHook(token, request) {\n  this.token = token;\n  this.key = request.headers['x-pusher-key'];\n  this.signature = request.headers['x-pusher-signature'];\n  this.contentType = request.headers['content-type'];\n  this.body = request.rawBody;\n\n  if (this.isContentTypeValid()) {\n    try {\n      this.data = JSON.parse(this.body);\n    } catch (e) {}\n  }\n}\n/** Checks whether the WebHook has valid body and signature.\n *\n * @param {Token|Token[]} list of additional tokens to be validated against\n * @returns {Boolean}\n */\n\n\nWebHook.prototype.isValid = function (extraTokens) {\n  if (!this.isBodyValid()) {\n    return false;\n  }\n\n  extraTokens = extraTokens || [];\n\n  if (!(extraTokens instanceof Array)) {\n    extraTokens = [extraTokens];\n  }\n\n  var tokens = [this.token].concat(extraTokens);\n\n  for (var i in tokens) {\n    var token = tokens[i];\n\n    if (this.key == token.key && token.verify(this.body, this.signature)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/** Checks whether the WebHook content type is valid.\n *\n * For now, the only valid WebHooks have content type of application/json.\n *\n * @returns {Boolean}\n */\n\n\nWebHook.prototype.isContentTypeValid = function () {\n  return this.contentType === \"application/json\";\n};\n/** Checks whether the WebHook content type and body is JSON.\n *\n * @returns {Boolean}\n */\n\n\nWebHook.prototype.isBodyValid = function () {\n  return this.data !== undefined;\n};\n/** Returns all WebHook data.\n *\n * @throws WebHookError when WebHook is invalid\n * @returns {Object}\n */\n\n\nWebHook.prototype.getData = function () {\n  if (!this.isBodyValid()) {\n    throw new errors.WebHookError(\"Invalid WebHook body\", this.contentType, this.body, this.signature);\n  }\n\n  return this.data;\n};\n/** Returns WebHook events array.\n *\n * @throws WebHookError when WebHook is invalid\n * @returns {Object[]}\n */\n\n\nWebHook.prototype.getEvents = function () {\n  return this.getData().events;\n};\n/** Returns WebHook timestamp.\n *\n * @throws WebHookError when WebHook is invalid\n * @returns {Date}\n */\n\n\nWebHook.prototype.getTime = function () {\n  return new Date(this.getData().time_ms);\n};\n\nmodule.exports = WebHook;","map":{"version":3,"sources":["C:/Users/Terre/Projects/WhatsApp/whatsapp-mern/node_modules/pusher/lib/webhook.js"],"names":["errors","require","util","Token","WebHook","token","request","key","headers","signature","contentType","body","rawBody","isContentTypeValid","data","JSON","parse","e","prototype","isValid","extraTokens","isBodyValid","Array","tokens","concat","i","verify","undefined","getData","WebHookError","getEvents","events","getTime","Date","time_ms","module","exports"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,QAAD,CAAlB;;AAEA,IAAIE,KAAK,GAAGF,OAAO,CAAC,SAAD,CAAnB;AAEA;;;;;;;;;;;;;AAWA,SAASG,OAAT,CAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAC/B,OAAKD,KAAL,GAAaA,KAAb;AAEA,OAAKE,GAAL,GAAWD,OAAO,CAACE,OAAR,CAAgB,cAAhB,CAAX;AACA,OAAKC,SAAL,GAAiBH,OAAO,CAACE,OAAR,CAAgB,oBAAhB,CAAjB;AACA,OAAKE,WAAL,GAAmBJ,OAAO,CAACE,OAAR,CAAgB,cAAhB,CAAnB;AACA,OAAKG,IAAL,GAAYL,OAAO,CAACM,OAApB;;AAEA,MAAI,KAAKC,kBAAL,EAAJ,EAA+B;AAC7B,QAAI;AACF,WAAKC,IAAL,GAAYC,IAAI,CAACC,KAAL,CAAW,KAAKL,IAAhB,CAAZ;AACD,KAFD,CAEE,OAAMM,CAAN,EAAS,CAAE;AACd;AACF;AAED;;;;;;;AAKAb,OAAO,CAACc,SAAR,CAAkBC,OAAlB,GAA4B,UAASC,WAAT,EAAsB;AAChD,MAAI,CAAC,KAAKC,WAAL,EAAL,EAAyB;AACvB,WAAO,KAAP;AACD;;AAEDD,EAAAA,WAAW,GAAGA,WAAW,IAAI,EAA7B;;AACA,MAAI,EAAEA,WAAW,YAAYE,KAAzB,CAAJ,EAAqC;AACnCF,IAAAA,WAAW,GAAG,CAACA,WAAD,CAAd;AACD;;AAED,MAAIG,MAAM,GAAG,CAAC,KAAKlB,KAAN,EAAamB,MAAb,CAAoBJ,WAApB,CAAb;;AACA,OAAK,IAAIK,CAAT,IAAcF,MAAd,EAAsB;AACpB,QAAIlB,KAAK,GAAGkB,MAAM,CAACE,CAAD,CAAlB;;AACA,QAAI,KAAKlB,GAAL,IAAYF,KAAK,CAACE,GAAlB,IAAyBF,KAAK,CAACqB,MAAN,CAAa,KAAKf,IAAlB,EAAwB,KAAKF,SAA7B,CAA7B,EAAsE;AACpE,aAAO,IAAP;AACD;AACF;;AACD,SAAO,KAAP;AACD,CAlBD;AAoBA;;;;;;;;AAMAL,OAAO,CAACc,SAAR,CAAkBL,kBAAlB,GAAuC,YAAW;AAChD,SAAO,KAAKH,WAAL,KAAqB,kBAA5B;AACD,CAFD;AAIA;;;;;;AAIAN,OAAO,CAACc,SAAR,CAAkBG,WAAlB,GAAgC,YAAW;AACzC,SAAO,KAAKP,IAAL,KAAca,SAArB;AACD,CAFD;AAIA;;;;;;;AAKAvB,OAAO,CAACc,SAAR,CAAkBU,OAAlB,GAA4B,YAAW;AACrC,MAAI,CAAC,KAAKP,WAAL,EAAL,EAAyB;AACvB,UAAM,IAAIrB,MAAM,CAAC6B,YAAX,CACJ,sBADI,EACoB,KAAKnB,WADzB,EACsC,KAAKC,IAD3C,EACiD,KAAKF,SADtD,CAAN;AAGD;;AACD,SAAO,KAAKK,IAAZ;AACD,CAPD;AASA;;;;;;;AAKAV,OAAO,CAACc,SAAR,CAAkBY,SAAlB,GAA8B,YAAW;AACvC,SAAO,KAAKF,OAAL,GAAeG,MAAtB;AACD,CAFD;AAIA;;;;;;;AAKA3B,OAAO,CAACc,SAAR,CAAkBc,OAAlB,GAA4B,YAAW;AACrC,SAAO,IAAIC,IAAJ,CAAS,KAAKL,OAAL,GAAeM,OAAxB,CAAP;AACD,CAFD;;AAIAC,MAAM,CAACC,OAAP,GAAiBhC,OAAjB","sourcesContent":["var errors = require('./errors');\nvar util = require('./util');\n\nvar Token = require('./token');\n\n/** Provides validation and access methods for a WebHook.\n *\n * Before accessing WebHook data, check if it's valid. Otherwise, exceptions\n * will be raised from access methods.\n *\n * @constructor\n * @param {Token} primary token\n * @param {Object} request\n * @param {Object} request.headers WebHook HTTP headers with lower-case keys\n * @param {String} request.rawBody raw WebHook body\n */\nfunction WebHook(token, request) {\n  this.token = token;\n\n  this.key = request.headers['x-pusher-key'];\n  this.signature = request.headers['x-pusher-signature'];\n  this.contentType = request.headers['content-type'];\n  this.body = request.rawBody;\n\n  if (this.isContentTypeValid()) {\n    try {\n      this.data = JSON.parse(this.body);\n    } catch(e) {}\n  }\n}\n\n/** Checks whether the WebHook has valid body and signature.\n *\n * @param {Token|Token[]} list of additional tokens to be validated against\n * @returns {Boolean}\n */\nWebHook.prototype.isValid = function(extraTokens) {\n  if (!this.isBodyValid()) {\n    return false;\n  }\n\n  extraTokens = extraTokens || [];\n  if (!(extraTokens instanceof Array)) {\n    extraTokens = [extraTokens];\n  }\n\n  var tokens = [this.token].concat(extraTokens);\n  for (var i in tokens) {\n    var token = tokens[i];\n    if (this.key == token.key && token.verify(this.body, this.signature)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/** Checks whether the WebHook content type is valid.\n *\n * For now, the only valid WebHooks have content type of application/json.\n *\n * @returns {Boolean}\n */\nWebHook.prototype.isContentTypeValid = function() {\n  return this.contentType === \"application/json\";\n};\n\n/** Checks whether the WebHook content type and body is JSON.\n *\n * @returns {Boolean}\n */\nWebHook.prototype.isBodyValid = function() {\n  return this.data !== undefined;\n};\n\n/** Returns all WebHook data.\n *\n * @throws WebHookError when WebHook is invalid\n * @returns {Object}\n */\nWebHook.prototype.getData = function() {\n  if (!this.isBodyValid()) {\n    throw new errors.WebHookError(\n      \"Invalid WebHook body\", this.contentType, this.body, this.signature\n    );\n  }\n  return this.data;\n};\n\n/** Returns WebHook events array.\n *\n * @throws WebHookError when WebHook is invalid\n * @returns {Object[]}\n */\nWebHook.prototype.getEvents = function() {\n  return this.getData().events;\n};\n\n/** Returns WebHook timestamp.\n *\n * @throws WebHookError when WebHook is invalid\n * @returns {Date}\n */\nWebHook.prototype.getTime = function() {\n  return new Date(this.getData().time_ms);\n};\n\nmodule.exports = WebHook;\n"]},"metadata":{},"sourceType":"script"}
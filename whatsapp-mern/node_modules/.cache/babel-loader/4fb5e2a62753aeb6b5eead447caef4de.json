{"ast":null,"code":"var crypto = require('crypto');\n\nvar url = require('url');\n\nvar auth = require('./auth');\n\nvar errors = require('./errors');\n\nvar events = require('./events');\n\nvar requests = require('./requests');\n\nvar util = require('./util');\n\nvar PusherConfig = require('./pusher_config');\n\nvar Token = require('./token');\n\nvar WebHook = require('./webhook');\n\nvar NotificationClient = require('./notification_client');\n\nvar validateChannel = function (channel) {\n  if (typeof channel !== \"string\" || channel === \"\" || channel.match(/[^A-Za-z0-9_\\-=@,.;]/)) {\n    throw new Error(\"Invalid channel name: '\" + channel + \"'\");\n  }\n\n  if (channel.length > 200) {\n    throw new Error(\"Channel name too long: '\" + channel + \"'\");\n  }\n};\n\nvar validateSocketId = function (socketId) {\n  if (typeof socketId !== \"string\" || socketId === \"\" || !socketId.match(/^\\d+\\.\\d+$/)) {\n    throw new Error(\"Invalid socket id: '\" + socketId + \"'\");\n  }\n};\n/** Callback passed to all REST API methods.\n *\n * @callback requestCallback\n * @param {RequestError} error\n * @param request\n * @param response\n */\n\n/** Provides access to Pusher's REST API, WebHooks and authentication.\n *\n * @constructor\n * @param {Object} options\n * @param {String} [options.host=\"api.pusherapp.com\"] API hostname\n * @param {String} [options.notification_host=\"api.pusherapp.com\"] Notification API hostname\n * @param {Boolean} [options.useTLS=false] whether to use TLS\n * @param {Boolean} [options.encrypted=false] deprecated; renamed to `useTLS`\n * @param {Boolean} [options.notification_encrypted=false] whether to use TLS for notifications\n * @param {Integer} [options.port] port, default depends on the scheme\n * @param {Integer} options.appId application ID\n * @param {String} options.key application key\n * @param {String} options.secret application secret\n * @param {String} [options.proxy] HTTP proxy to channel requests through\n * @param {Integer} [options.timeout] request timeout in milliseconds\n * @param {Boolean} [options.keepAlive] whether requests should use keep-alive\n */\n\n\nfunction Pusher(options) {\n  this.config = new PusherConfig(options);\n  var notificationOptions = util.mergeObjects({}, options, {\n    host: options.notificationHost,\n    encrypted: options.notificationEncrypted\n  });\n  this.notificationClient = new NotificationClient(notificationOptions);\n}\n/** Create a Pusher instance using a URL.\n *\n * URL should be in SCHEME://APP_KEY:SECRET_KEY@HOST:PORT/apps/APP_ID form.\n *\n * @param {String} pusherUrl URL containing endpoint and app details\n * @param {Object} [options] options, see the {@link Pusher} for details\n * @returns {Pusher} instance configured for the URL and options\n */\n\n\nPusher.forURL = function (pusherUrl, options) {\n  var apiUrl = url.parse(pusherUrl);\n  var apiPath = apiUrl.pathname.split(\"/\");\n  var apiAuth = apiUrl.auth.split(\":\");\n  return new Pusher(util.mergeObjects({}, options || {}, {\n    scheme: apiUrl.protocol.replace(/:$/, \"\"),\n    host: apiUrl.hostname,\n    port: parseInt(apiUrl.port, 10) || undefined,\n    appId: parseInt(apiPath[apiPath.length - 1], 10),\n    key: apiAuth[0],\n    secret: apiAuth[1]\n  }));\n};\n/** Create a Pusher instance using a cluster name.\n *\n * @param {String} cluster cluster name\n * @param {Object} [options] options, see the {@link Pusher} for details\n * @returns {Pusher} instance configured for the cluster and options\n */\n\n\nPusher.forCluster = function (cluster, options) {\n  return new Pusher(util.mergeObjects({}, options || {}, {\n    host: \"api-\" + cluster + \".pusher.com\"\n  }));\n};\n/** Returns a signature for given socket id, channel and socket data.\n *\n * @param {String} socketId socket id\n * @param {String} channel channel name\n * @param {Object} [data] additional socket data\n * @returns {String} authentication signature\n */\n\n\nPusher.prototype.authenticate = function (socketId, channel, data) {\n  validateSocketId(socketId);\n  validateChannel(channel);\n  return auth.getSocketSignature(this, this.config.token, channel, socketId, data);\n};\n/** Triggers an event.\n *\n * Channel names can contain only characters which are alphanumeric, '_' or '-'\n * and have to be at most 200 characters long.\n *\n * Event name can be at most 200 characters long.\n *\n * Calls back with three arguments - error, request and response. When request\n * completes with code < 400, error will be null. Otherwise, error will be\n * populated with response details.\n *\n * @param {String|String[]} channel list of at most 100 channels\n * @param {String} event event name\n * @param data event data, objects are JSON-encoded\n * @param {String} [socketId] id of a socket that should not receive the event\n * @param {requestCallback} [callback]\n * @see RequestError\n */\n\n\nPusher.prototype.trigger = function (channels, event, data, socketId, callback) {\n  if (typeof socketId === \"function\") {\n    callback = socketId;\n    socketId = undefined;\n  }\n\n  if (socketId) {\n    validateSocketId(socketId);\n  }\n\n  if (!(channels instanceof Array)) {\n    // add single channel to array for multi trigger compatibility\n    channels = [channels];\n  }\n\n  if (event.length > 200) {\n    throw new Error(\"Too long event name: '\" + event + \"'\");\n  }\n\n  if (channels.length > 100) {\n    throw new Error(\"Can't trigger a message to more than 100 channels\");\n  }\n\n  for (var i = 0; i < channels.length; i++) {\n    validateChannel(channels[i]);\n  }\n\n  events.trigger(this, channels, event, data, socketId, callback);\n};\n/* Triggers a batch of events\n*\n* @param {Event[]} An array of events, where Event is\n* {\n*   name: string,\n*   channel: string,\n*   data: any JSON-encodable data\n* }\n*/\n\n\nPusher.prototype.triggerBatch = function (batch, callback) {\n  events.triggerBatch(this, batch, callback);\n};\n\nPusher.prototype.notify = function () {\n  this.notificationClient.notify.apply(this.notificationClient, arguments);\n};\n/** Makes a POST request to Pusher, handles the authentication.\n *\n * Calls back with three arguments - error, request and response. When request\n * completes with code < 400, error will be null. Otherwise, error will be\n * populated with response details.\n *\n * @param {Object} options\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {String} options.body request body\n * @param {requestCallback} [callback]\n * @see RequestError\n */\n\n\nPusher.prototype.post = function (options, callback) {\n  requests.send(this.config, util.mergeObjects({}, options, {\n    method: \"POST\"\n  }), callback);\n};\n/** Makes a GET request to Pusher, handles the authentication.\n *\n * Calls back with three arguments - error, request and response. When request\n * completes with code < 400, error will be null. Otherwise, error will be\n * populated with response details.\n *\n * @param {Object} options\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {requestCallback} [callback]\n * @see RequestError\n */\n\n\nPusher.prototype.get = function (options, callback) {\n  requests.send(this.config, util.mergeObjects({}, options, {\n    method: \"GET\"\n  }), callback);\n};\n/** Creates a WebHook object for a given request.\n *\n * @param {Object} request\n * @param {Object} request.headers WebHook HTTP headers with lower-case keys\n * @param {String} request.rawBody raw WebHook body\n * @returns {WebHook}\n */\n\n\nPusher.prototype.webhook = function (request) {\n  return new WebHook(this.config.token, request);\n};\n/** Builds a signed query string that can be used in a request to Pusher.\n *\n * @param {Object} options\n * @param {String} options.method request method\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {String} options.body request body\n * @returns {String} signed query string\n */\n\n\nPusher.prototype.createSignedQueryString = function (options) {\n  return requests.createSignedQueryString(this.config.token, options);\n};\n\nPusher.prototype.channelSharedSecret = function (channel) {\n  return crypto.createHash('sha256').update(channel + this.config.encryptionMasterKey).digest();\n};\n/** Exported {@link Token} constructor. */\n\n\nPusher.Token = Token;\n/** Exported {@link RequestError} constructor. */\n\nPusher.RequestError = errors.RequestError;\n/** Exported {@link WebHookError} constructor. */\n\nPusher.WebHookError = errors.WebHookError;\nmodule.exports = Pusher;","map":{"version":3,"sources":["C:/Users/Terre/Projects/WhatsApp/whatsapp-mern/node_modules/pusher/lib/pusher.js"],"names":["crypto","require","url","auth","errors","events","requests","util","PusherConfig","Token","WebHook","NotificationClient","validateChannel","channel","match","Error","length","validateSocketId","socketId","Pusher","options","config","notificationOptions","mergeObjects","host","notificationHost","encrypted","notificationEncrypted","notificationClient","forURL","pusherUrl","apiUrl","parse","apiPath","pathname","split","apiAuth","scheme","protocol","replace","hostname","port","parseInt","undefined","appId","key","secret","forCluster","cluster","prototype","authenticate","data","getSocketSignature","token","trigger","channels","event","callback","Array","i","triggerBatch","batch","notify","apply","arguments","post","send","method","get","webhook","request","createSignedQueryString","channelSharedSecret","createHash","update","encryptionMasterKey","digest","RequestError","WebHookError","module","exports"],"mappings":"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","sourcesContent":["var crypto = require('crypto');\nvar url = require('url');\n\nvar auth = require('./auth');\nvar errors = require('./errors');\nvar events = require('./events');\nvar requests = require('./requests');\nvar util = require('./util');\n\nvar PusherConfig = require('./pusher_config');\nvar Token = require('./token');\nvar WebHook = require('./webhook');\nvar NotificationClient = require('./notification_client');\n\nvar validateChannel = function(channel) {\n  if (typeof channel !== \"string\" || channel === \"\" || channel.match(/[^A-Za-z0-9_\\-=@,.;]/)) {\n    throw new Error(\"Invalid channel name: '\" + channel + \"'\");\n  }\n  if (channel.length > 200) {\n    throw new Error(\"Channel name too long: '\" + channel + \"'\");\n  }\n};\n\nvar validateSocketId = function(socketId) {\n  if (typeof socketId !== \"string\" || socketId === \"\" || !socketId.match(/^\\d+\\.\\d+$/)) {\n    throw new Error(\"Invalid socket id: '\" + socketId + \"'\");\n  }\n};\n\n/** Callback passed to all REST API methods.\n *\n * @callback requestCallback\n * @param {RequestError} error\n * @param request\n * @param response\n */\n\n/** Provides access to Pusher's REST API, WebHooks and authentication.\n *\n * @constructor\n * @param {Object} options\n * @param {String} [options.host=\"api.pusherapp.com\"] API hostname\n * @param {String} [options.notification_host=\"api.pusherapp.com\"] Notification API hostname\n * @param {Boolean} [options.useTLS=false] whether to use TLS\n * @param {Boolean} [options.encrypted=false] deprecated; renamed to `useTLS`\n * @param {Boolean} [options.notification_encrypted=false] whether to use TLS for notifications\n * @param {Integer} [options.port] port, default depends on the scheme\n * @param {Integer} options.appId application ID\n * @param {String} options.key application key\n * @param {String} options.secret application secret\n * @param {String} [options.proxy] HTTP proxy to channel requests through\n * @param {Integer} [options.timeout] request timeout in milliseconds\n * @param {Boolean} [options.keepAlive] whether requests should use keep-alive\n */\nfunction Pusher(options) {\n  this.config = new PusherConfig(options);\n  var notificationOptions = util.mergeObjects({}, options, {\n    host: options.notificationHost,\n    encrypted: options.notificationEncrypted\n  });\n  this.notificationClient = new NotificationClient(notificationOptions);\n}\n\n/** Create a Pusher instance using a URL.\n *\n * URL should be in SCHEME://APP_KEY:SECRET_KEY@HOST:PORT/apps/APP_ID form.\n *\n * @param {String} pusherUrl URL containing endpoint and app details\n * @param {Object} [options] options, see the {@link Pusher} for details\n * @returns {Pusher} instance configured for the URL and options\n */\nPusher.forURL = function(pusherUrl, options) {\n  var apiUrl = url.parse(pusherUrl);\n  var apiPath = apiUrl.pathname.split(\"/\");\n  var apiAuth = apiUrl.auth.split(\":\");\n\n  return new Pusher(util.mergeObjects({}, options || {}, {\n    scheme: apiUrl.protocol.replace(/:$/, \"\"),\n    host: apiUrl.hostname,\n    port: parseInt(apiUrl.port, 10) || undefined,\n    appId: parseInt(apiPath[apiPath.length-1], 10),\n    key: apiAuth[0],\n    secret: apiAuth[1]\n  }));\n};\n\n/** Create a Pusher instance using a cluster name.\n *\n * @param {String} cluster cluster name\n * @param {Object} [options] options, see the {@link Pusher} for details\n * @returns {Pusher} instance configured for the cluster and options\n */\nPusher.forCluster = function(cluster, options) {\n  return new Pusher(util.mergeObjects({}, options || {}, {\n    host: \"api-\" + cluster + \".pusher.com\"\n  }));\n};\n\n/** Returns a signature for given socket id, channel and socket data.\n *\n * @param {String} socketId socket id\n * @param {String} channel channel name\n * @param {Object} [data] additional socket data\n * @returns {String} authentication signature\n */\nPusher.prototype.authenticate = function(socketId, channel, data) {\n  validateSocketId(socketId);\n  validateChannel(channel);\n\n  return auth.getSocketSignature(this, this.config.token, channel, socketId, data);\n};\n\n/** Triggers an event.\n *\n * Channel names can contain only characters which are alphanumeric, '_' or '-'\n * and have to be at most 200 characters long.\n *\n * Event name can be at most 200 characters long.\n *\n * Calls back with three arguments - error, request and response. When request\n * completes with code < 400, error will be null. Otherwise, error will be\n * populated with response details.\n *\n * @param {String|String[]} channel list of at most 100 channels\n * @param {String} event event name\n * @param data event data, objects are JSON-encoded\n * @param {String} [socketId] id of a socket that should not receive the event\n * @param {requestCallback} [callback]\n * @see RequestError\n */\nPusher.prototype.trigger = function(channels, event, data, socketId, callback) {\n  if (typeof socketId === \"function\") {\n    callback = socketId;\n    socketId = undefined;\n  }\n\n  if (socketId) {\n    validateSocketId(socketId);\n  }\n  if (!(channels instanceof Array)) {\n    // add single channel to array for multi trigger compatibility\n    channels = [channels];\n  }\n  if (event.length > 200) {\n    throw new Error(\"Too long event name: '\" + event + \"'\");\n  }\n  if (channels.length > 100) {\n    throw new Error(\"Can't trigger a message to more than 100 channels\");\n  }\n  for (var i = 0; i < channels.length; i++) {\n    validateChannel(channels[i]);\n  }\n  events.trigger(this, channels, event, data, socketId, callback);\n};\n\n/* Triggers a batch of events\n*\n* @param {Event[]} An array of events, where Event is\n* {\n*   name: string,\n*   channel: string,\n*   data: any JSON-encodable data\n* }\n*/\nPusher.prototype.triggerBatch = function(batch, callback) {\n  events.triggerBatch(this, batch, callback);\n}\n\nPusher.prototype.notify = function() {\n  this.notificationClient.notify.apply(this.notificationClient, arguments);\n}\n\n/** Makes a POST request to Pusher, handles the authentication.\n *\n * Calls back with three arguments - error, request and response. When request\n * completes with code < 400, error will be null. Otherwise, error will be\n * populated with response details.\n *\n * @param {Object} options\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {String} options.body request body\n * @param {requestCallback} [callback]\n * @see RequestError\n */\nPusher.prototype.post = function(options, callback) {\n  requests.send(\n    this.config, util.mergeObjects({}, options, { method: \"POST\" }), callback\n  );\n};\n\n/** Makes a GET request to Pusher, handles the authentication.\n *\n * Calls back with three arguments - error, request and response. When request\n * completes with code < 400, error will be null. Otherwise, error will be\n * populated with response details.\n *\n * @param {Object} options\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {requestCallback} [callback]\n * @see RequestError\n */\nPusher.prototype.get = function(options, callback) {\n  requests.send(\n    this.config, util.mergeObjects({}, options, { method: \"GET\" }), callback\n  );\n};\n\n/** Creates a WebHook object for a given request.\n *\n * @param {Object} request\n * @param {Object} request.headers WebHook HTTP headers with lower-case keys\n * @param {String} request.rawBody raw WebHook body\n * @returns {WebHook}\n */\nPusher.prototype.webhook = function(request) {\n  return new WebHook(this.config.token, request);\n};\n\n/** Builds a signed query string that can be used in a request to Pusher.\n *\n * @param {Object} options\n * @param {String} options.method request method\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {String} options.body request body\n * @returns {String} signed query string\n */\nPusher.prototype.createSignedQueryString = function(options) {\n  return requests.createSignedQueryString(this.config.token, options);\n};\n\nPusher.prototype.channelSharedSecret = function(channel) {\n  return crypto.createHash('sha256').update(channel + this.config.encryptionMasterKey).digest();\n}\n\n/** Exported {@link Token} constructor. */\nPusher.Token = Token;\n/** Exported {@link RequestError} constructor. */\nPusher.RequestError = errors.RequestError;\n/** Exported {@link WebHookError} constructor. */\nPusher.WebHookError = errors.WebHookError;\n\nmodule.exports = Pusher;\n"]},"metadata":{},"sourceType":"script"}
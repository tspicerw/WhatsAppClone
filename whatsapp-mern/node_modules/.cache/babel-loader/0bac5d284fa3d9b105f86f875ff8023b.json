{"ast":null,"code":"var util = require('./util');\n\nvar nacl = require('tweetnacl');\n\nvar naclUtil = require('tweetnacl-util');\n\nfunction encrypt(pusher, channel, data) {\n  if (pusher.config.encryptionMasterKey === undefined) {\n    throw new Error(\"Set encryptionMasterKey before triggering events on encrypted channels\");\n  }\n\n  var nonceBytes = nacl.randomBytes(24);\n  var ciphertextBytes = nacl.secretbox(naclUtil.decodeUTF8(JSON.stringify(data)), nonceBytes, pusher.channelSharedSecret(channel));\n  return JSON.stringify({\n    nonce: naclUtil.encodeBase64(nonceBytes),\n    ciphertext: naclUtil.encodeBase64(ciphertextBytes)\n  });\n}\n\nexports.trigger = function (pusher, channels, eventName, data, socketId, callback) {\n  if (channels.length === 1 && util.isEncryptedChannel(channels[0])) {\n    var channel = channels[0];\n    var event = {\n      \"name\": eventName,\n      \"data\": encrypt(pusher, channel, data),\n      \"channels\": [channel]\n    };\n\n    if (socketId) {\n      event.socket_id = socketId;\n    }\n\n    pusher.post({\n      path: '/events',\n      body: event\n    }, callback);\n  } else {\n    for (var i = 0; i < channels.length; i++) {\n      if (util.isEncryptedChannel(channels[i])) {\n        // For rationale, see limitations of end-to-end encryption in the README\n        throw new Error(\"You cannot trigger to multiple channels when using encrypted channels\");\n      }\n    }\n\n    var event = {\n      \"name\": eventName,\n      \"data\": ensureJSON(data),\n      \"channels\": channels\n    };\n\n    if (socketId) {\n      event.socket_id = socketId;\n    }\n\n    pusher.post({\n      path: '/events',\n      body: event\n    }, callback);\n  }\n};\n\nexports.triggerBatch = function (pusher, batch, callback) {\n  for (var i = 0; i < batch.length; i++) {\n    batch[i].data = util.isEncryptedChannel(batch[i].channel) ? encrypt(pusher, batch[i].channel, batch[i].data) : ensureJSON(batch[i].data);\n  }\n\n  pusher.post({\n    path: '/batch_events',\n    body: {\n      batch: batch\n    }\n  }, callback);\n};\n\nfunction ensureJSON(data) {\n  return typeof data === 'string' ? data : JSON.stringify(data);\n}","map":{"version":3,"sources":["C:/Users/Terre/Projects/WhatsApp/whatsapp-mern/node_modules/pusher/lib/events.js"],"names":["util","require","nacl","naclUtil","encrypt","pusher","channel","data","config","encryptionMasterKey","undefined","Error","nonceBytes","randomBytes","ciphertextBytes","secretbox","decodeUTF8","JSON","stringify","channelSharedSecret","nonce","encodeBase64","ciphertext","exports","trigger","channels","eventName","socketId","callback","length","isEncryptedChannel","event","socket_id","post","path","body","i","ensureJSON","triggerBatch","batch"],"mappings":"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","sourcesContent":["var util = require('./util');\nvar nacl = require('tweetnacl');\nvar naclUtil = require('tweetnacl-util');\n\nfunction encrypt(pusher, channel, data) {\n  if (pusher.config.encryptionMasterKey === undefined) {\n    throw new Error(\"Set encryptionMasterKey before triggering events on encrypted channels\");\n  }\n\n  var nonceBytes = nacl.randomBytes(24);\n\n  var ciphertextBytes = nacl.secretbox(\n    naclUtil.decodeUTF8(JSON.stringify(data)),\n    nonceBytes,\n    pusher.channelSharedSecret(channel));\n\n  return JSON.stringify({\n    nonce: naclUtil.encodeBase64(nonceBytes),\n    ciphertext: naclUtil.encodeBase64(ciphertextBytes)\n  });\n}\n\nexports.trigger = function(pusher, channels, eventName, data, socketId, callback) {\n  if (channels.length === 1 && util.isEncryptedChannel(channels[0])) {\n    var channel = channels[0];\n    var event = {\n      \"name\": eventName,\n      \"data\": encrypt(pusher, channel, data),\n      \"channels\": [channel]\n    };\n    if (socketId) {\n      event.socket_id = socketId;\n    }\n    pusher.post({ path: '/events', body: event }, callback);\n  } else {\n    for (var i = 0; i < channels.length; i++) {\n      if (util.isEncryptedChannel(channels[i])) {\n        // For rationale, see limitations of end-to-end encryption in the README\n        throw new Error(\"You cannot trigger to multiple channels when using encrypted channels\");\n      }\n    }\n\n    var event = {\n      \"name\": eventName,\n      \"data\": ensureJSON(data),\n      \"channels\": channels\n    };\n    if (socketId) {\n      event.socket_id = socketId;\n    }\n    pusher.post({ path: '/events', body: event }, callback);\n  }\n}\n\nexports.triggerBatch = function(pusher, batch, callback) {\n  for (var i = 0; i < batch.length; i++) {\n    batch[i].data = util.isEncryptedChannel(batch[i].channel) ?\n      encrypt(pusher, batch[i].channel, batch[i].data) :\n      ensureJSON(batch[i].data);\n  }\n  pusher.post({ path: '/batch_events', body: { batch: batch } }, callback);\n}\n\nfunction ensureJSON(data) {\n  return typeof data === 'string' ? data : JSON.stringify(data);\n}\n"]},"metadata":{},"sourceType":"script"}